% To display a curve obtained using de Casteljau subdivision
% Used by run_decas-subdiv2
% returns the x and y coordinates of the sequence of points
% as row vectors
% The polyline is not plotted by this function
% n = level of recursion
% 
%  cpoly is a 2 x (m+1) matrix whose first row consists of x-coordinates
%  and second row of y-coordinates of m + 1 control points

function [x,y] = decas_subdiv2(bx, by, n)
    if (size(bx,2) > size(bx,1))
        bx = transpose(bx);
        by = transpose(by);
    end
    if (n == 0)
        [x,y] = [bx,by];
    else
        lpoly(1,:,2^0) = bx;
        lpoly(2,:,2^0) = by;
        for i = 1:n
            lpoly = subdivstep(lpoly)
        end
    end
    
    % Create vectors x and y
    row = size(lpoly,2);
    z = size(lpoly,3);
    longpoly = [];
    for i = 1:z
        if i == 1
            longpoly = cat(2, longpoly,lpoly(:,:,i));
        else
            for j = 2:row
            longpoly = cat(2, longpoly,lpoly(:,j,i));
            end
        end
        
    end
%     disp(longpoly);
    x = longpoly(1,:);
    y = longpoly(2,:);
    
%     result = cat(1, final_ud, final_ul);
%     i=1;
%     j=size(result,1);
%     while i < j
%         if (result(i,1) == result(i+1,1))
%             result(i,:) = [];
%         end
%         i = i+1;
%         j=size(result,1);
%     end
%     x = result(:,1);
%     y = result(:,2);
end

% subdivstep that takes a 2 × 4 × l array lpoly consisting of l 
% control polygons and produces a 2 × 4 × 2l array in which each control 
% polygon lpoly(:,:,i) is subdivided into two control polygons using 
% subdecas
function [lpoly2] = subdivstep(lpoly)
    [x,y,z] = size(lpoly);
    lpoly2 = zeros(x,y,2*z);
    for i = 1:z
        bx = lpoly(1,:,i);
        by = lpoly(2,:,i);
        bx = transpose(bx);
        by = transpose(by);
        [ud,ld] = subdecas(bx,by);
        ud = transpose(ud);
        ld = transpose(ld);
        lpoly2(:,:,(i*2)-1) = ud;
        lpoly2(:,:,(i*2)) = ld;
    end
%     for i = 1:z
%         bx = lpoly(1,:,i);
%         by = lpoly(2,:,i);
%         bx = transpose(bx);
%         by = transpose(by);
%         [ud,ld] = subdecas(bx,by);
%         ud = transpose(ud);
%         ld = transpose(ld);
%         lpoly2 = cat(3, lpoly2, ud, ld);
%     end
end

function [ud,ld] = subdecas(bx,by) % takes 4 points and generates 7.
% takes the 7 points, makes 2 sets by dupping the middle pt. 2x4.
    m = size(by,1) ;
    m1 = m;
    %n1 = (m-1)*2^n+1; %number of "final" points OVERALL
    n2 = (m*(m+1))/2; %number of total points
    n3 = ((m-2)*(m-1))/2; %number of points to delete
    n1 = n2 - n3; %number of points generated by this m only

    result_x = zeros(n1,2);
    result_y = zeros(n1,1);

    %triangle index: the offset for labelling the points
    tri_ind = 1;
    result_x(1,1) = bx(1,:);
    result_x(2,1) = bx(m,:);
    %label point 1 and m
    result_x(1,2) = 1;
    result_x(2,2) = n1;

    result_y(1) = by(1);
    result_y(2) = by(m);

    t = 0.5;
    j = 1;
    %because k is our resultx variable, we start after the new points
    k = 3;

    while m ~= 1
        x = zeros(m-1,1);
        y = zeros(m-1,1);
        for i=1:m-1
            x(i) = (1-t) * bx(i) + t*bx(i+1);
            y(i) = (1-t) * by(i) + t*by(i+1);
            if (i==1)
                result_x(k,:) = [x(i), tri_ind + 1];
                result_y(k) = y(i);
                k = k+1;
            elseif (i == m-1)
                result_x(k,:) = [x(i), n1 - tri_ind];
                result_y(k) = y(i);
                k = k+1;
            end
        end
        bx = x;
        by = y;
        m = m-1;
        tri_ind = tri_ind + 1;
    end

    A = zeros(n1, 2);
    A(:,1) = transpose(result_x(:,2));
    A(:,2) = transpose(result_x(:,1));
    A(:,3) = transpose(result_y);
    A = sortrows(A);
    result_x = A(:,2);
    result_y = A(:,3);
    udx = result_x(1:m1);
    udy = result_y(1:m1);
    ldx = result_x(m1:end);
    ldy = result_y(m1:end);
    ud = [udx,udy];
    ld = [ldx,ldy];
end