% To display a curve obtained using de Casteljau subdivision
% Used by run_decas-subdiv2
% returns the x and y coordinates of the sequence of points
% as row vectors
% The polyline is not plotted by this function
% n = level of recursion
% 
%  cpoly is a 2 x (m+1) matrix whose first row consists of x-coordinates
%  and second row of y-coordinates of m + 1 control points

function [x,y] = decas_subdiv2(bx, by, n)
    if (size(bx,2) > size(bx,1))
        bx = transpose(bx);
        by = transpose(by);
    end
    [final_ud, final_ul] = subdiv(bx, by, n);
    result = cat(1, final_ud, final_ul);
    i=1;
    j=size(result,1);
    while i < j
        if (result(i,1) == result(i+1,1))
            result(i,:) = [];
        end
        i = i+1;
        j=size(result,1);
    end
    x = result(:,1);
    y = result(:,2);
end

function [ud,ld] = subdiv(bx, by, n)
    [ud, ld] = handle_leg(bx, by);
    if (n==1)
        return;
    end
    for M=1:n-1
        [ud1, ld1] = subdiv(ud(:,1), ud(:,2), 1);
        ud = cat(1, ud1, ld1);
        [ud2, ld2] = subdiv(ld(:,1), ld(:,2), 1);
        ld = cat(1, ud2, ld2);
    end
end

function [ud,ld] = handle_leg(bx,by)
    m = size(by,1) ;
    m1 = m;
    %n1 = (m-1)*2^n+1; %number of "final" points OVERALL
    n2 = (m*(m+1))/2; %number of total points
    n3 = ((m-2)*(m-1))/2; %number of points to delete
    n1 = n2 - n3; %number of points generated by this m only

    result_x = zeros(n1,2);
    result_y = zeros(n1,1);

    %triangle index: the offset for labelling the points
    tri_ind = 1;
    result_x(1,1) = bx(1,:);
    result_x(2,1) = bx(m,:);
    %label point 1 and m
    result_x(1,2) = 1;
    result_x(2,2) = n1;

    result_y(1) = by(1);
    result_y(2) = by(m);

    t = 0.5;
    j = 1;
    %because k is our resultx variable, we start after the new points
    k = 3;

    while m ~= 1
        x = zeros(m-1,1);
        y = zeros(m-1,1);
        for i=1:m-1
            x(i) = (1-t) * bx(i) + t*bx(i+1);
            y(i) = (1-t) * by(i) + t*by(i+1);
            if (i==1)
                result_x(k,:) = [x(i), tri_ind + 1];
                result_y(k) = y(i);
                k = k+1;
            elseif (i == m-1)
                result_x(k,:) = [x(i), n1 - tri_ind];
                result_y(k) = y(i);
                k = k+1;
            end
        end
        bx = x;
        by = y;
        m = m-1;
        tri_ind = tri_ind + 1;
    end

    A = zeros(n1, 2);
    A(:,1) = transpose(result_x(:,2));
    A(:,2) = transpose(result_x(:,1));
    A(:,3) = transpose(result_y);
    A = sortrows(A);
    result_x = A(:,2);
    result_y = A(:,3);
    udx = result_x(1:m1);
    udy = result_y(1:m1);
    ldx = result_x(m1:end);
    ldy = result_y(m1:end);
    ud = [udx,udy];
    ld = [ldx,ldy];
end
